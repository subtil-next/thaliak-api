/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-production-install",
factory: function (require) {
"use strict";var plugin=(()=>{var H=Object.defineProperty;var Y=Object.getOwnPropertyDescriptor;var Z=Object.getOwnPropertyNames;var G=Object.prototype.hasOwnProperty;var g=(l=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(l,{get:(t,e)=>(typeof require<"u"?require:t)[e]}):l)(function(l){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+l+'" is not supported')});var I=(l,t)=>{for(var e in t)H(l,e,{get:t[e],enumerable:!0})},Q=(l,t,e,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of Z(t))!G.call(l,o)&&o!==e&&H(l,o,{get:()=>t[o],enumerable:!(r=Y(t,o))||r.enumerable});return l};var X=l=>Q(H({},"__esModule",{value:!0}),l);var oe={};I(oe,{default:()=>re});var d=g("@yarnpkg/core");var U=g("@yarnpkg/core"),x=class{constructor(t){this.resolvers=t.filter(e=>e)}supportsDescriptor(t,e){return!!this.tryResolverByDescriptor(t,e)}supportsLocator(t,e){return!!this.tryResolverByLocator(t,e)}shouldPersistResolution(t,e){return this.getResolverByLocator(t,e).shouldPersistResolution(t,e)}bindDescriptor(t,e,r){return this.getResolverByDescriptor(t,r).bindDescriptor(t,e,r)}getResolutionDependencies(t,e){return this.getResolverByDescriptor(t,e).getResolutionDependencies(t,e)}async getCandidates(t,e,r){return await this.getResolverByDescriptor(t,r).getCandidates(t,e,r)}async getSatisfying(t,e,r,o){return this.getResolverByDescriptor(t,o).getSatisfying(t,e,r,o)}async resolve(t,e){return await this.getResolverByLocator(t,e).resolve(t,e)}tryResolverByDescriptor(t,e){let r=this.resolvers.find(o=>o.supportsDescriptor(t,e));return r||null}getResolverByDescriptor(t,e){let r=this.resolvers.find(o=>o.supportsDescriptor(t,e));if(!r)throw new Error(`${U.structUtils.prettyDescriptor(e.project.configuration,t)} isn't supported by any available resolver`);return r}tryResolverByLocator(t,e){let r=this.resolvers.find(o=>o.supportsLocator(t,e));return r||null}getResolverByLocator(t,e){let r=this.resolvers.find(o=>o.supportsLocator(t,e));if(!r)throw new Error(`${U.structUtils.prettyLocator(e.project.configuration,t)} isn't supported by any available resolver`);return r}};var V=g("@yarnpkg/core"),$=g("@yarnpkg/cli"),p=g("@yarnpkg/fslib"),J=g("@yarnpkg/plugin-patch"),E=g("@yarnpkg/plugin-pack"),_=g("@yarnpkg/plugin-pnp"),y=g("clipanion");var C={};I(C,{getDependents:()=>ee});async function ee(l,t){let e=[];for(let r of l.storedPackages.values())for(let o of r.dependencies.values())if(l.storedResolutions.get(o.descriptorHash)===t.locatorHash){e.push(r);break}return e}var m=g("@yarnpkg/fslib");async function F(l,t,e){return await m.xfs.mkdirpPromise(m.ppath.dirname(m.ppath.resolve(t,e))),m.xfs.copyFilePromise(m.ppath.resolve(l,e),m.ppath.resolve(t,e))}async function z(l,t,e,r=[],o=!1){return K(m.ppath.resolve(l,e),m.ppath.resolve(t,e),r,o)}async function K(l,t,e=[],r=!1){if((await m.xfs.lstatPromise(l)).isDirectory()){await m.xfs.existsPromise(t)||await m.xfs.mkdirpPromise(t);let o=await m.xfs.readdirPromise(l);for(let n of o){let s=m.ppath.resolve(l,n),i=m.ppath.resolve(t,n);(()=>{for(let f of e)if(s.endsWith(f))return!0;return!1})()||((await m.xfs.lstatPromise(s)).isDirectory()?await K(s,i,e,r):r?await m.xfs.linkPromise(s,i):await m.xfs.copyFilePromise(s,i))}}else throw new Error("src not a folder")}var a=g("@yarnpkg/core"),P=g("@yarnpkg/fslib"),O=g("@yarnpkg/plugin-pack"),N=g("@yarnpkg/libzip"),T=class{constructor({fetcher:t,project:e,cache:r}){this.fetcher=t,this.project=e,this.cache=r}supports(t,e){return this.fetcher.supports(t,{project:e.project,fetcher:this})}getLocalPath(t,e){return t.reference.startsWith(a.WorkspaceResolver.protocol)&&t.reference!==`${a.WorkspaceResolver.protocol}.`?null:this.fetcher.getLocalPath(t,{project:e.project,fetcher:this,cache:e.cache,cacheOptions:e.cacheOptions,checksums:e.checksums,report:e.report})}async fetch(t,e){let r=e.checksums.get(t.locatorHash)||null;if(t.reference.startsWith(a.WorkspaceResolver.protocol)&&t.reference!==`${a.WorkspaceResolver.protocol}.`){let n=await this.makeTemporaryCache(e.cache),[s,i]=await n.fetchPackageFromCache(t,r,{onHit:()=>e.report.reportCacheHit(t),onMiss:()=>e.report.reportCacheMiss(t,`${a.structUtils.prettyLocator(e.project.configuration,t)} can't be found in the cache and will be packed from disk.`),loader:async()=>this.packWorkspace(t,{project:e.project,fetcher:this,cache:e.cache,cacheOptions:e.cacheOptions,checksums:e.checksums,report:e.report})});return n.markedFiles.forEach(v=>e.cache.markedFiles.add(v)),{packageFs:s,releaseFs:i,prefixPath:a.structUtils.getIdentVendorPath(t),checksum:n.cacheKey}}let o=this.cache.getLocatorPath(t,r);if(o&&o.endsWith(".zip")&&await P.xfs.existsPromise(o)){let n=e.cache.getLocatorPath(t,r);if(n&&!await P.xfs.existsPromise(n))try{await P.xfs.linkPromise(o,n)}catch{await P.xfs.existsPromise(n)||e.report.reportError(a.MessageName.FETCH_FAILED,`Failed to link the cache entry for ${a.structUtils.prettyLocator(e.cache.configuration,t)}`)}let s=await a.hashUtils.checksumFile(n),i,v=new P.LazyFS(()=>a.miscUtils.prettifySyncErrors(()=>i=new N.ZipFS(n,{baseFs:P.xfs,readOnly:!0}),c=>`Failed to open the cache entry for ${a.structUtils.prettyLocator(e.project.configuration,t)}: ${c}`),P.ppath);return{packageFs:new P.AliasFS(n,{baseFs:v,pathUtils:P.ppath}),releaseFs:()=>{i?.discardAndClose()},prefixPath:a.structUtils.getIdentVendorPath(t),checksum:s}}return this.fetcher.fetch(t,{project:e.project,fetcher:this,cache:e.cache,cacheOptions:e.cacheOptions,checksums:e.checksums,report:e.report})}async packWorkspace(t,{report:e}){let{configuration:r}=this.project,o=this.project.getWorkspaceByLocator(t);return P.xfs.mktempPromise(async n=>{let s=a.structUtils.slugifyLocator(t),i=P.ppath.join(n,`${s}-pack.log`),v=`# This file contains the result of Yarn calling packing "${s}" ("${o.cwd}")
`,{stdout:f,stderr:h}=r.getSubprocessStreams(i,{report:e,prefix:a.structUtils.prettyLocator(r,o.anchoredLocator),header:v}),c=await a.StreamReport.start({configuration:r,stdout:f},async()=>{});try{let u;return await O.packUtils.prepareForPack(o,{report:c},async()=>{c.reportJson({base:o.cwd});let k=await O.packUtils.genPackList(o);for(let R of k)c.reportInfo(null,R),c.reportJson({location:R});let L=await O.packUtils.genPackStream(o,k);u=await a.miscUtils.bufferStream(L)}),await a.miscUtils.releaseAfterUseAsync(async()=>await a.tgzUtils.convertToZip(u,{configuration:r,stripComponents:1,prefixPath:a.structUtils.getIdentVendorPath(t)}))}catch(u){throw P.xfs.detachTemp(n),u instanceof Error&&h.write(u.stack),new a.ReportError(a.MessageName.LIFECYCLE_SCRIPT,`Packing ${s} failed, logs can be found here: ${a.formatUtils.pretty(r,i,a.formatUtils.Type.PATH)}); run ${a.formatUtils.pretty(r,`yarn ${P.ppath.relative(this.project.cwd,o.cwd)} pack`,a.formatUtils.Type.CODE)} to investigate`)}finally{await c.finalize(),f.end(),h.end()}})}async makeTemporaryCache(t){let{configuration:{startingCwd:e,plugins:r},check:o,immutable:n,cwd:s}=t,i=a.Configuration.create(e,r);return i.useWithSource("<plugin>",{enableMirror:!1},e,{overwrite:!0}),new a.Cache(s,{configuration:i,check:o,immutable:n})}};var w=g("@yarnpkg/core"),M=class{constructor({resolver:t,project:e,stripTypes:r=!0}){this.resolver=t,this.project=e,this.stripTypes=r}supportsDescriptor(t,e){return t=e.project.configuration.normalizeDependency(t),this.resolver.supportsDescriptor(t,{project:e.project,resolver:this})}supportsLocator(t,e){return t=e.project.configuration.normalizeLocator(t),this.resolver.supportsLocator(t,{project:e.project,resolver:this})}shouldPersistResolution(t,e){return t=e.project.configuration.normalizeLocator(t),t.reference.startsWith(w.WorkspaceResolver.protocol)?!1:this.resolver.shouldPersistResolution(t,{project:e.project,resolver:this})}bindDescriptor(t,e,r){return t=r.project.configuration.normalizeDependency(t),e=r.project.configuration.normalizeLocator(e),this.resolver.bindDescriptor(t,e,{project:r.project,resolver:this})}getResolutionDependencies(t,e){return t=e.project.configuration.normalizeDependency(t),this.resolver.getResolutionDependencies(t,{project:e.project,resolver:this})}async getCandidates(t,e,r){return t=r.project.configuration.normalizeDependency(t),t.range.startsWith(w.WorkspaceResolver.protocol)&&t.range!==`${w.WorkspaceResolver.protocol}.`?[this.project.getWorkspaceByDescriptor(t).anchoredLocator]:this.resolver.getCandidates(t,e,{project:r.project,resolver:this,fetchOptions:r.fetchOptions,report:r.report})}async resolve(t,e){t=e.project.configuration.normalizeLocator(t);let o=await(async()=>{if(t.reference.startsWith(w.WorkspaceResolver.protocol)&&t.reference!==`${w.WorkspaceResolver.protocol}.`){let s=this.project.getWorkspaceByLocator(t);return{...t,version:s.manifest.version||"0.0.0",languageName:"unknown",linkType:w.LinkType.HARD,dependencies:new Map([...s.manifest.dependencies]),peerDependencies:new Map([...s.manifest.peerDependencies]),dependenciesMeta:s.manifest.dependenciesMeta,peerDependenciesMeta:s.manifest.peerDependenciesMeta,bin:s.manifest.bin}}return this.resolver.resolve(t,{project:e.project,resolver:this,fetchOptions:e.fetchOptions,report:e.report})})(),n=new Map;for(let[s,i]of o.dependencies.entries())this.stripTypes&&i.scope==="types"||n.set(s,i);return{...o,dependencies:n}}async getSatisfying(t,e,r,o){t=o.project.configuration.normalizeDependency(t),r=r.map(s=>o.project.configuration.normalizeLocator(s));let n=await o.project.configuration.getPackageExtensions();return Object.keys(e).forEach(s=>e[s]=o.project.configuration.normalizePackage(e[s],{packageExtensions:n})),this.resolver.getSatisfying(t,e,r,{project:o.project,resolver:this,fetchOptions:o.fetchOptions,report:o.report})}};var D=class extends y.Command{constructor(){super(...arguments);this.outDirectory=y.Option.String({name:"outDirectory"});this.json=y.Option.Boolean("--json",!1,{description:"Format the output as an NDJSON stream"});this.stripTypes=y.Option.Boolean("--strip-types",!0,{description:"Use --no-strip-types to not strip `@types/*` dependencies"});this.pack=y.Option.Boolean("--pack",!1);this.silent=y.Option.Boolean("--silent",!1,{hidden:!0});this.production=y.Option.Boolean("--production",!0,{description:"Use --no-production to not strip devDependencies"});this.injectCjsPnp=y.Option.String("--injectCjsPnp","",{description:"Expermental!: Use --injectCjsPnp to inject a require to the .pnp.cjs file, this requires pack to be enabled"})}async execute(){let e=await d.Configuration.find(this.context.cwd,this.context.plugins),{project:r,workspace:o}=await d.Project.find(e,this.context.cwd);if(await r.restoreInstallState(),!o)throw new $.WorkspaceRequiredError(r.cwd,this.context.cwd);let n=await d.Cache.find(e,{immutable:!0,check:!1}),s=r.topLevelWorkspace.cwd,i=p.npath.isAbsolute(this.outDirectory)?p.npath.toPortablePath(this.outDirectory):p.ppath.join(o.cwd,p.npath.toPortablePath(this.outDirectory));return(await d.StreamReport.start({configuration:e,json:this.json,stdout:this.context.stdout},async f=>{await f.startTimerPromise("Setting up production directory",async()=>{await p.xfs.mkdirpPromise(i),await F(s,i,p.Filename.lockfile),await F(s,i,e.get("rcFilename")),await F(o.cwd,i,p.Filename.manifest);let h=[],c=u=>{try{e.get(u)&&h.push(e.get(u))}catch{}};c("installStatePath"),c("cacheFolder"),c("deferredVersionFolder"),await e.triggerHook(u=>u.populateYarnPaths,r,u=>{u&&h.push(u)}),await z(s,i,".yarn",h)}),await f.startTimerPromise("Installing production version",async()=>{let h=await d.Configuration.find(i,this.context.plugins);if(this.stripTypes){let b=await h.getPackageExtensions();for(let j of b.values())for(let[,q]of j)for(let B of q)B.type===d.PackageExtensionType.Dependency&&B.descriptor.scope==="types"&&(B.status=d.PackageExtensionStatus.Inactive)}let{project:c,workspace:u}=await d.Project.find(h,i);if(!u)throw new $.WorkspaceRequiredError(r.cwd,this.context.cwd);this.production&&u.manifest.devDependencies.clear();for(let[b,j]of r.resolutionAliases)c.resolutionAliases.set(b,j);let k=await d.Cache.find(h,{immutable:!1,check:!1}),L=h.makeFetcher(),R=e.makeResolver(),S=new x([new V.LockfileResolver(R),R]),A=new M({project:r,resolver:S,stripTypes:this.stripTypes}),W=new T({cache:n,fetcher:L,project:r});await this.modifyOriginalResolutions(c,A,{project:c,fetchOptions:{cache:k,project:c,fetcher:W,checksums:c.storedChecksums,report:f},resolver:A,report:f}),await c.install({cache:k,report:f,immutable:!1,fetcher:W,resolver:A,checkResolutions:!1,persistProject:!1}),await f.startTimerPromise("Cleaning up unused dependencies",async()=>{let b=[];b.push(...await this.getPatchSourcesToRemove(c,k));for(let j of b)await p.xfs.existsPromise(j)&&(f.reportInfo(d.MessageName.UNUSED_CACHE_ENTRY,`${p.ppath.basename(j)} appears to be unused - removing`),await p.xfs.removePromise(j))})}),this.pack&&(await f.startTimerPromise("Packing workspace ",async()=>{await E.packUtils.prepareForPack(o,{report:f},async()=>{f.reportJson({base:o.cwd});let h=await E.packUtils.genPackList(o);for(let c of h)if(f.reportInfo(null,c),f.reportJson({location:c}),c.endsWith(p.Filename.manifest)){let u=await E.packUtils.genPackageManifest(o);await p.xfs.writeJsonPromise(p.ppath.resolve(i,c),u)}else await F(o.cwd,i,c)})}),this.injectCjsPnp&&await f.startTimerPromise("Injecting .pnp.cjs call into file ",async()=>{let h=p.npath.isAbsolute(this.injectCjsPnp)?p.npath.toPortablePath(this.injectCjsPnp):p.ppath.join(i,p.npath.toPortablePath(this.injectCjsPnp));await p.xfs.statPromise(h);let c=await p.xfs.readFilePromise(h,"utf8"),u=await d.Configuration.find(i,this.context.plugins),{project:k}=await d.Project.find(u,i),{cjs:L}=(0,_.getPnpPath)(k),S=`require('${p.ppath.relative(p.ppath.dirname(h),L)}').setup()
${c}`;await p.xfs.writeFilePromise(h,S)}))})).exitCode()}async getPatchSourcesToRemove(e,r){let o=[];e.storedPackages.forEach(s=>{s.reference.startsWith("patch:")&&o.push(s)});let n=[];for(let s of o){let{sourceLocator:i}=J.patchUtils.parseLocator(s),v=e.storedPackages.get(i.locatorHash);if(!v)break;if((await C.getDependents(e,v)).filter(h=>h.locatorHash!==s.locatorHash).length>0){let h=r.getLocatorPath(i,e.storedChecksums.get(i.locatorHash)??null);h&&n.push(h)}}return n}async modifyOriginalResolutions(e,r,o){await o.report.startTimerPromise("Modifying original install state",async()=>{for(let[n,s]of e.originalPackages.entries()){let i=await r.resolve(s,o);e.originalPackages.set(n,i)}})}};D.paths=[["prod-install"]],D.usage=y.Command.Usage({description:"INSTALL!",details:"prod only install",examples:[["Install the project with only prod dependencies","$0 prod-install"]]});var te={commands:[D]},re=te;return X(oe);})();
return plugin;
}
};
